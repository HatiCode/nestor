package models

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

// Version represents a component version for history tracking
type Version struct {
	Version      string     `json:"version" validate:"required,semver"`
	CreatedAt    time.Time  `json:"created_at"`
	GitCommit    string     `json:"git_commit,omitempty"`
	Deprecated   bool       `json:"deprecated"`
	DeprecatedAt *time.Time `json:"deprecated_at,omitempty"`
}

type ComponentVersion struct {
	ComponentName   string              `json:"component_name"`
	Version         string              `json:"version"`
	VersionInfo     SemanticVersionInfo `json:"version_info"`
	CreatedAt       time.Time           `json:"created_at"`
	CreatedBy       string              `json:"created_by"`
	GitCommit       string              `json:"git_commit"`
	GitBranch       string              `json:"git_branch"`
	ReleaseNotes    string              `json:"release_notes"`
	Checksum        string              `json:"checksum"`
	PreviousVersion *string             `json:"previous_version,omitempty"`
	Status          VersionStatus       `json:"status"`
}

type SemanticVersionInfo struct {
	Major      int    `json:"major"`
	Minor      int    `json:"minor"`
	Patch      int    `json:"patch"`
	PreRelease string `json:"pre_release,omitempty"`
	Build      string `json:"build,omitempty"`
	Raw        string `json:"raw"`
}

type VersionStatus string

const (
	VersionStatusActive     VersionStatus = "active"
	VersionStatusDeprecated VersionStatus = "deprecated"
	VersionStatusYanked     VersionStatus = "yanked"
	VersionStatusDraft      VersionStatus = "draft"
)

type ComponentChange struct {
	ID                  string                 `json:"id"`
	ComponentName       string                 `json:"component_name"`
	Version             string                 `json:"version"`
	ChangeType          ChangeType             `json:"change_type"`
	ChangedBy           string                 `json:"changed_by"`
	ChangedAt           time.Time              `json:"changed_at"`
	GitCommit           string                 `json:"git_commit"`
	GitBranch           string                 `json:"git_branch"`
	Changes             []FieldChange          `json:"changes"`
	Summary             string                 `json:"summary"`
	Rollback            *RollbackInfo          `json:"rollback,omitempty"`
	SemanticVersionInfo *SemanticVersionChange `json:"semantic_version_info"`
}

type ChangeType string

const (
	ChangeTypeCreate   ChangeType = "create"
	ChangeTypeUpdate   ChangeType = "update"
	ChangeTypeDelete   ChangeType = "delete"
	ChangeTypeRestore  ChangeType = "restore"
	ChangeTypeRollback ChangeType = "rollback"
	ChangeTypeYank     ChangeType = "yank"
)

type FieldChange struct {
	Field     string `json:"field"`
	OldValue  any    `json:"old_value"`
	NewValue  any    `json:"new_value"`
	Operation string `json:"operation"`
}

type SemanticVersionChange struct {
	PreviousVersion string `json:"previous_version"`
	NewVersion      string `json:"new_version"`
	VersionType     string `json:"version_type"`
	BreakingChanges bool   `json:"breaking_changes"`
	Reason          string `json:"reason"`
	AutoGenerated   bool   `json:"auto_generated"`
}

type RollbackInfo struct {
	TargetVersion string    `json:"target_version"`
	Reason        string    `json:"reason"`
	RolledBackAt  time.Time `json:"rolled_back_at"`
	RolledBackBy  string    `json:"rolled_back_by"`
}

type VersionDiff struct {
	ComponentName string        `json:"component_name"`
	FromVersion   string        `json:"from_version"`
	ToVersion     string        `json:"to_version"`
	Changes       []FieldChange `json:"changes"`
	Summary       DiffSummary   `json:"summary"`
	GeneratedAt   time.Time     `json:"generated_at"`
}

type DiffSummary struct {
	TotalChanges           int      `json:"total_changes"`
	BreakingChanges        int      `json:"breaking_changes"`
	IsBackwardCompatible   bool     `json:"is_backward_compatible"`
	ChangedFields          []string `json:"changed_fields"`
	AddedFields            []string `json:"added_fields"`
	RemovedFields          []string `json:"removed_fields"`
	RecommendedVersionBump string   `json:"recommended_version_bump"`
}

type VersionConstraint struct {
	Raw      string              `json:"raw"`
	Operator ConstraintOperator  `json:"operator"`
	Version  SemanticVersionInfo `json:"version"`
	Ranges   []VersionRange      `json:"ranges"`
}

type ConstraintOperator string

const (
	OperatorEqual        ConstraintOperator = "="
	OperatorGreaterThan  ConstraintOperator = ">"
	OperatorGreaterEqual ConstraintOperator = ">="
	OperatorLessThan     ConstraintOperator = "<"
	OperatorLessEqual    ConstraintOperator = "<="
	OperatorTilde        ConstraintOperator = "~"
	OperatorCaret        ConstraintOperator = "^"
	OperatorAny          ConstraintOperator = "*"
)

type VersionRange struct {
	Min        SemanticVersionInfo `json:"min"`
	Max        SemanticVersionInfo `json:"max"`
	IncludeMin bool                `json:"include_min"`
	IncludeMax bool                `json:"include_max"`
}

func ParseSemanticVersion(version string) (*SemanticVersionInfo, error) {
	v := strings.TrimPrefix(version, "v")
	buildParts := strings.Split(v, "+")
	v = buildParts[0]
	build := ""
	if len(buildParts) > 1 {
		build = buildParts[1]
	}

	preReleaseParts := strings.Split(v, "-")
	v = preReleaseParts[0]
	preRelease := ""
	if len(preReleaseParts) > 1 {
		preRelease = strings.Join(preReleaseParts[1:], "-")
	}

	parts := strings.Split(v, ".")
	if len(parts) != 3 {
		return nil, fmt.Errorf("invalid semantic version format: %s", version)
	}

	major, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil, fmt.Errorf("invalid major version: %s", parts[0])
	}

	minor, err := strconv.Atoi(parts[1])
	if err != nil {
		return nil, fmt.Errorf("invalid minor version: %s", parts[1])
	}

	patch, err := strconv.Atoi(parts[2])
	if err != nil {
		return nil, fmt.Errorf("invalid patch version: %s", parts[2])
	}

	return &SemanticVersionInfo{
		Major:      major,
		Minor:      minor,
		Patch:      patch,
		PreRelease: preRelease,
		Build:      build,
		Raw:        version,
	}, nil
}

func (v *SemanticVersionInfo) String() string {
	version := fmt.Sprintf("%d.%d.%d", v.Major, v.Minor, v.Patch)

	if v.PreRelease != "" {
		version += "-" + v.PreRelease
	}

	if v.Build != "" {
		version += "=" + v.Build
	}

	return version
}

func (v *SemanticVersionInfo) Compare(other *SemanticVersionInfo) int {
	if v.Major != other.Major {
		if v.Major < other.Major {
			return -1
		}
		return 1
	}

	if v.Minor != other.Minor {
		if v.Minor < other.Minor {
			return -1
		}
		return 1
	}

	if v.Patch != other.Patch {
		if v.Patch < other.Patch {
			return -1
		}
		return 1
	}

	if v.PreRelease == "" && other.PreRelease != "" {
		return 1
	}
	if v.PreRelease != "" && other.PreRelease == "" {
		return -1
	}
	if v.PreRelease != other.PreRelease {
		if v.PreRelease < other.PreRelease {
			return -1
		}
		return 1
	}

	return 0
}

func (v *SemanticVersionInfo) IsPreRelease() bool {
	return v.PreRelease != ""
}

func (v *SemanticVersionInfo) IsStable() bool {
	return !v.IsPreRelease()
}

func (v *SemanticVersionInfo) NextMajor() *SemanticVersionInfo {
	return &SemanticVersionInfo{
		Major:      v.Major + 1,
		Minor:      0,
		Patch:      0,
		PreRelease: "",
		Build:      "",
		Raw:        fmt.Sprintf("%d.0.0", v.Major+1),
	}
}

func (v *SemanticVersionInfo) NextMinor() *SemanticVersionInfo {
	return &SemanticVersionInfo{
		Major:      v.Major,
		Minor:      v.Minor + 1,
		Patch:      0,
		PreRelease: "",
		Build:      "",
		Raw:        fmt.Sprintf("%d.%d.0", v.Major, v.Minor+1),
	}
}

func (v *SemanticVersionInfo) NextPatch() *SemanticVersionInfo {
	return &SemanticVersionInfo{
		Major:      v.Major,
		Minor:      v.Minor,
		Patch:      v.Patch + 1,
		PreRelease: "",
		Build:      "",
		Raw:        fmt.Sprintf("%d.%d.%d", v.Major, v.Minor, v.Patch+1),
	}
}

// VersionHistory represents the version history of a component
type VersionHistory struct {
	ComponentName string    `json:"component_name" validate:"required"`
	Versions      []Version `json:"versions"`
	TotalCount    int       `json:"total_count"`
}

// GetLatestVersion returns the latest non-deprecated version, or the latest deprecated version if all are deprecated
func (vh *VersionHistory) GetLatestVersion() *Version {
	if len(vh.Versions) == 0 {
		return nil
	}

	// First try to find the latest non-deprecated version
	for _, version := range vh.Versions {
		if !version.Deprecated {
			return &version
		}
	}

	// If all versions are deprecated, return the first one (should be the latest)
	return &vh.Versions[0]
}

// GetLatestNonDeprecatedVersion returns the latest non-deprecated version
func (vh *VersionHistory) GetLatestNonDeprecatedVersion() *Version {
	for _, version := range vh.Versions {
		if !version.Deprecated {
			return &version
		}
	}
	return nil
}

// IsDeprecated returns true if the version is deprecated
func (v *Version) IsDeprecated() bool {
	return v.Deprecated || v.DeprecatedAt != nil
}

// GetSemanticVersion parses and returns the semantic version information
func (v *Version) GetSemanticVersion() (*SemanticVersionInfo, error) {
	return ParseSemanticVersion(v.Version)
}

func (cv *ComponentVersion) GetID() string {
	return cv.ComponentName + ":" + cv.Version
}

func (cv *ComponentVersion) IsActive() bool {
	return cv.Status == VersionStatusActive
}

func (cv *ComponentVersion) IsDeprecated() bool {
	return cv.Status == VersionStatusDeprecated
}

func (cv *ComponentVersion) IsYanked() bool {
	return cv.Status == VersionStatusYanked
}

type ConstraintParser interface {
	Parse(constraint string) (*VersionConstraint, error)
}

type constraintRule struct {
	prefix   string
	operator ConstraintOperator
	trimLen  int
}

type tableConstraintParser struct {
	rules []constraintRule
}

func NewConstraintParser() ConstraintParser {
	return &tableConstraintParser{
		rules: []constraintRule{
			{">=", OperatorGreaterEqual, 2},
			{"<=", OperatorLessEqual, 2},
			{">", OperatorGreaterThan, 1},
			{"<", OperatorLessThan, 1},
			{"~", OperatorTilde, 1},
			{"^", OperatorCaret, 1},
		},
	}
}

func (p *tableConstraintParser) Parse(constraint string) (*VersionConstraint, error) {
	constraint = strings.TrimSpace(constraint)

	if constraint == "*" {
		return &VersionConstraint{
			Raw:      constraint,
			Operator: OperatorAny,
		}, nil
	}

	for _, rule := range p.rules {
		if strings.HasPrefix(constraint, rule.prefix) {
			return p.parseWithRule(constraint, rule)
		}
	}

	return p.parseExactMatch(constraint)
}

func (p *tableConstraintParser) parseWithRule(constraint string, rule constraintRule) (*VersionConstraint, error) {
	versionStr := strings.TrimSpace(constraint[rule.trimLen:])
	version, err := ParseSemanticVersion(versionStr)
	if err != nil {
		return nil, fmt.Errorf("invalid version in constraint %q: %w", constraint, err)
	}

	return &VersionConstraint{
		Raw:      constraint,
		Operator: rule.operator,
		Version:  *version,
	}, nil
}

func (p *tableConstraintParser) parseExactMatch(constraint string) (*VersionConstraint, error) {
	version, err := ParseSemanticVersion(constraint)
	if err != nil {
		return nil, fmt.Errorf("invalid version constraint %q: %w", constraint, err)
	}

	return &VersionConstraint{
		Raw:      constraint,
		Operator: OperatorEqual,
		Version:  *version,
	}, nil
}

func (vc *VersionConstraint) Satisfies(version *SemanticVersionInfo) bool {
	switch vc.Operator {
	case OperatorAny:
		return true
	case OperatorEqual:
		return version.Compare(&vc.Version) == 0
	case OperatorGreaterThan:
		return version.Compare(&vc.Version) > 0
	case OperatorGreaterEqual:
		return version.Compare(&vc.Version) >= 0
	case OperatorLessThan:
		return version.Compare(&vc.Version) < 0
	case OperatorLessEqual:
		return version.Compare(&vc.Version) <= 0
	case OperatorTilde:
		if version.Major != vc.Version.Major || version.Minor != vc.Version.Minor {
			return false
		}
		return version.Compare(&vc.Version) >= 0
	case OperatorCaret:
		if version.Major != vc.Version.Major {
			return false
		}
		return version.Compare(&vc.Version) >= 0
	default:
		return false
	}
}

func (vd *VersionDiff) IsBreaking() bool {
	return vd.Summary.BreakingChanges > 0
}

func (vd *VersionDiff) GetRecommendedVersionBump() string {
	if vd.Summary.BreakingChanges > 0 {
		return "major"
	}
	if len(vd.Summary.AddedFields) > 0 || vd.Summary.TotalChanges > 0 {
		return "minor"
	}
	return "patch"
}
